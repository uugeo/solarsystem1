<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>太陽系シミュレーション</title>
  <style>
    body { margin: 0; color: white; background: #000; font-family: sans-serif; }
    canvas { display: block; background-color: black; }
    .controls { padding: 10px; background: #111; display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    label { margin-right: 6px; }
    button { margin-right: 6px; }
    .group { display:flex; align-items:center; gap:6px; }
    .value { min-width: 44px; text-align:right; display:inline-block; }
  </style>
</head>
<body>
  <h1 style="margin:10px;">太陽系シミュレーション（8惑星）</h1>
  <canvas id="solarCanvas"></canvas>

  <div class="controls">
    <div class="group">
      <label for="speed">時間:</label>
      <input type="range" id="speed" min="1" max="200" value="1">
      <span class="value" id="speedVal"></span>
    </div>

    <div class="group">
      <label for="scale">スケール:</label>
      <input type="range" id="scale" min="30" max="300" value="120">
      <span class="value" id="scaleVal"></span>
    </div>

    <button id="resetBtn">元に戻す（ランダム）</button>
    <button id="lineStartBtn">一直線開始</button>

    <div class="group">
      <label for="toggleSun">太陽</label>
      <input type="checkbox" id="toggleSun" checked>
    </div>
  </div>

<script>
const canvas = document.getElementById('solarCanvas');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight - 140;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const AU = 1.0;

// ★ スケールは可変
let SCALE = 120;

// 共通角速度（speedFactorで倍率）
const OMEGA_BASE = 2 * Math.PI / 40;

let speedFactor = 1;
let showSun = true;

// 8惑星（平均軌道長半径 AU）
const initial = [
  { name: 'Mercury', rAU: 0.387, color: 'gray' },
  { name: 'Venus',   rAU: 0.723, color: 'gold' },
  { name: 'Earth',   rAU: 1.000, color: 'dodgerblue' },
  { name: 'Mars',    rAU: 1.524, color: 'red' },
  { name: 'Jupiter', rAU: 5.203, color: 'orange' },
  { name: 'Saturn',  rAU: 9.537, color: 'khaki' },
  { name: 'Uranus',  rAU: 19.19, color: 'lightcyan' },
  { name: 'Neptune', rAU: 30.07, color: 'deepskyblue' }
];

const planets = initial.map(p => ({
  name: p.name,
  r: p.rAU * AU,
  color: p.color,
  angle: 0,
  x: 0, y: 0,
  vx: 0, vy: 0,
  trail: []
}));

function randAngle() {
  return Math.random() * Math.PI * 2;
}

function worldToScreen(wx, wy) {
  return {
    x: canvas.width / 2 + wx * SCALE,
    y: canvas.height / 2 + wy * SCALE
  };
}

function clearTrails() {
  planets.forEach(pl => pl.trail = []);
}

function drawSun() {
  const cx = canvas.width / 2;
  const cy = canvas.height / 2;
  ctx.beginPath();
  ctx.arc(cx, cy, 10, 0, Math.PI * 2);
  ctx.fillStyle = 'red';
  ctx.fill();
}

function drawPlanets() {
  ctx.font = "13px sans-serif";
  planets.forEach(pl => {
    const s = worldToScreen(pl.x, pl.y);

    // 軌跡（画面座標で保存）
    pl.trail.push({ x: s.x, y: s.y });
    if (pl.trail.length > 2500) pl.trail.shift();

    ctx.beginPath();
    ctx.moveTo(pl.trail[0].x, pl.trail[0].y);
    for (const pt of pl.trail) ctx.lineTo(pt.x, pt.y);
    ctx.strokeStyle = pl.color;
    ctx.lineWidth = 1;
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(s.x, s.y, 4, 0, Math.PI * 2);
    ctx.fillStyle = pl.color;
    ctx.fill();

    ctx.fillStyle = 'white';
    ctx.fillText(pl.name, s.x + 6, s.y - 6);
  });
}

function updateFromAngle(pl) {
  pl.x = pl.r * Math.cos(pl.angle);
  pl.y = pl.r * Math.sin(pl.angle);
}

function updateCircular(dt) {
  const omega = OMEGA_BASE * speedFactor;
  planets.forEach(pl => {
    pl.angle += omega * dt;
    updateFromAngle(pl);
  });
}

function switchToInertial() {
  const omega = OMEGA_BASE * speedFactor;
  planets.forEach(pl => {
    const v = omega * pl.r;
    pl.vx = -Math.sin(pl.angle) * v;
    pl.vy =  Math.cos(pl.angle) * v;
  });
}

function switchToCircular() {
  planets.forEach(pl => {
    pl.angle = Math.atan2(pl.y, pl.x);
    updateFromAngle(pl);
  });
}

function updateInertial(dt) {
  planets.forEach(pl => {
    pl.x += pl.vx * dt;
    pl.y += pl.vy * dt;
  });
}

function resetRandom() {
  planets.forEach((pl, i) => {
    pl.r = initial[i].rAU * AU;
    pl.angle = randAngle();
    updateFromAngle(pl);
    pl.trail = [];
  });
}

function startOnLine() {
  const a = 0;
  planets.forEach((pl, i) => {
    pl.r = initial[i].rAU * AU;
    pl.angle = a;
    updateFromAngle(pl);
    pl.trail = [];
  });
}

let lastTs = null;
function animate(ts) {
  if (!lastTs) lastTs = ts;
  const dt = (ts - lastTs) / 1000;
  lastTs = ts;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (showSun) drawSun();
  drawPlanets();

  if (showSun) updateCircular(dt);
  else updateInertial(dt);

  requestAnimationFrame(animate);
}

// UI
const speed = document.getElementById('speed');
const speedVal = document.getElementById('speedVal');
const scale = document.getElementById('scale');
const scaleVal = document.getElementById('scaleVal');

function syncLabels() {
  speedVal.textContent = speedFactor;
  scaleVal.textContent = SCALE;
}

speed.addEventListener('input', e => {
  speedFactor = Number(e.target.value);
  syncLabels();
  if (!showSun) switchToInertial();
});

scale.addEventListener('input', e => {
  SCALE = Number(e.target.value);
  syncLabels();
  // ★ スケール変更で軌跡の見た目が破綻しないようリセット
  clearTrails();
});

document.getElementById('toggleSun').addEventListener('change', e => {
  const next = e.target.checked;
  if (showSun && !next) switchToInertial();
  if (!showSun && next) switchToCircular();
  showSun = next;
});

document.getElementById('resetBtn').addEventListener('click', resetRandom);
document.getElementById('lineStartBtn').addEventListener('click', startOnLine);

// 初期化（速度最小、スケールはスライダー値）
speedFactor = Number(speed.value);
SCALE = Number(scale.value);
syncLabels();
resetRandom();
requestAnimationFrame(animate);
</script>
</body>
</html>
